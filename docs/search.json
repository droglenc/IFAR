[
  {
    "objectID": "dedication.html",
    "href": "dedication.html",
    "title": "Dedication",
    "section": "",
    "text": "I have been fortunate enough to have had three significant mentors during my career.\n\nNicholas Bystrom was my basketball coach and statistics and mathematics professor at Northland College. “Coach” helped me understand, very early in my career, the power, utility, and beauty of mathematics and statistics.\nJames Selgeby was my boss for a work-study position with the U.S. Fish and Wildlife Service during my last two years at Northland College. Jim trusted me as a fisheries scientist, fostered my passion for Great Lakes fisheries, and encouraged me to pursue an advanced degree in fisheries.\nGeorge Spangler was my doctoral advisor at the University of Minnesota. George strongly encouraged advanced studies in statistics, supported my interest in programming, and provided an environment, as a graduate student and later while on sabbatical, where I could creatively mix statistics, programming, and fisheries.\n\nThis book would not exist without each of these great men. I dedicate this work to them.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNick at the board, Northland College ca. 1995.\n\n\n\n\n\n\n\nDerek and Jim following Jim’s honorary degree reception at Northland College, 2007.\n\n\n\n\n\n\n\nDerek and George, December, 2015.\n\n\n\n\n\n\n\nNick coaching basketball, Northland College ca. 1987.\n\n\n\n\n\n\n\nJim at his desk, ca. 1990.\n\n\n\n\n\n\n\nGeorge, Don Pereira, Shannon Davis-Foust, and Derek at the national AFS meeting in Minneapolis, 2012.\n\n\n\n\n\n\n\nNick and I (#15) with the Rest of the Team, 1986.\n\n\n\n\n\n\n\nGeorge sailing on Lake Pepin, ca. 2008.\n\n\n\n\n\n\n\nNick and I in deep discussion, ca. 1998.\n\n\n\n\n\n Previous\n\n\n Next"
  },
  {
    "objectID": "errata.html",
    "href": "errata.html",
    "title": "Errata & Notes",
    "section": "",
    "text": "Page 86, Footnote 7 – “Ager C” should be “Ager B”.\nPage 207, Equation for \\(\\hat{Z}\\) – \\(N\\) should be \\(n\\) in the denominator. Thus, the new equation should be\n\n\\[\\hat{Z} = -log(\\hat{S}) - \\frac{(n-1)(n-2)}{n(T+1)(n+T-1)} \\]"
  },
  {
    "objectID": "errata.html#post-production-changes",
    "href": "errata.html#post-production-changes",
    "title": "Errata & Notes",
    "section": "Post-Production Changes",
    "text": "Post-Production Changes\n\nThroughout – I have removed filterD() from FSA. Please see this fishR post for how to accomplish the same effect using functions from dplyr.\nSection 2.4 – The maintainers of tidyr suggest using pivot_longer() instead of gather() and pivot_wider() instead of spread(), though gather() and spread() still work as shown in the book.\nSection 4.2 – I have dramatically changed the age-bias plot that is produced by plot() with an object saved from ageBias(). This change is described in the documentation and examples for ageBias(). The plots shown in the book can largely still be produced with plotAB() (see its documentation here). Also see this fishR post for a description of constructing an age-bias plot using ggplot2.\nSection 4.4 – I have changed the information that is returned from agePrecision(). All of the information shown in the book is still provided; however, other information (e.g., average standard deviation and mean absolute deviation) are now also returned. The output is documented in the documentation for agePrecision().\nSections 7.3.3, 8.3.2.1, 12.3.6, and 13.2.2 – residPlot() has been removed from the FSA package. Other methods for constructing residuals plots are discussed in this fishR post.\nSections 12.3.1 and 13.1 – The dynamic plots described for finding starting values for a von Bertalanffy growth function and the stock-recruitment functions (i.e., nonlinear regressions) have been removed from vbStarts() and srStarts(), because of the difficulty of maintaining a package that requires the tcltk package. These functionalities are now in the FSAsims package, but it can also largely be replicated with the fixed= arguments to vbStarts() and srStarts(). Use of fixed= in srStarts() is demonstrated in this blog post."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IFAR",
    "section": "",
    "text": "Introductory Fisheries Analyses with R by Derek H. Ogle provides detailed instructions on how to perform basic fisheries stock assessment analyses in the R environment. The analyses covered are typical analyses for many working fisheries scientists and, thus, also occur in most upper-level undergraduate and graduate level fisheries science, analysis, or management courses. The book begins with three foundational chapters that help the reader become familiar with R within the context of basic fisheries analyses and examples. The remaining chapters build upon these foundational skills with analytical techniques specific to fisheries stock assessments. A preview is available from Google Books.\nThe book is dedicated to my three professional mentors."
  },
  {
    "objectID": "index.html#table-of-contents-with-resources",
    "href": "index.html#table-of-contents-with-resources",
    "title": "IFAR",
    "section": "Table of Contents (with Resources)",
    "text": "Table of Contents (with Resources)\n\n(Very Brief) Introduction to R Basics\n\nThe bare fundamentals of R that are required for the remainder of the book.\nR Script\n\nLoading Data and Basic Manipulations\n\nLoad data into R from external files and perform typical manipulations including filtering, sorting, aggregating, joining, and converting between wide- and long-formats.\nR Script and Data: BGHRfish.csv, BGHRsample.csv, inchAge.csv, inchBio.csv, inchBio07.csv, inchBio08.csv, inchGear.csv\nSupplements: Backcalculation of Previous Length\nExercises\n\nPlotting Fundamentals\n\nThe bare fundamentals for constructing basic plots using base R.\nR Script and Data:\nSupplements: Common Axis Labels on a Grid of Subplots, Complex Grid Layouts\nExercises\n\nAge Comparisons\n\nCompare two or more estimates of age for the same fish with precision and bias metrics and plots.\nR Script and Data: ShadCR.csv\nExercises\n\nAge-Length Keys\n\nAssign ages to unaged fish from their length and an age-length-key.\nR Script and Data: CreekChub.csv, SiscowetMI2004.csv\nExercises\n\nSize Structure\n\nAssess size structure through length frequencies and the proportional size distribution (PSD) metric.\nR Script and Data: InchLake1113.csv\nExercises\n\nWeight-Length Relationships\n\nIntroduction to simple linear regression through examination of weight-length relationships.\nR Script and Data: RuffeSLRH.csv\nSupplements: DVR with More than Two Groups\nExercises\n\nCondition\n\nCompute condition metrics from observed length and weights. Introduction to one-way ANOVA.\nR Script and Data: RuffeSLRH.csv\nExercises\n\nAbundance from Capture-Recapture Data\n\nEstimate abundance from capture-recapture data for closed (single and multiple recapture events) and open populations.\nR Script and Data: CutthroatAL.csv, Zehfussetal_1985_mod.INP\nExercises\n\nAbundance from Depletion Data\n\nEstimate abundance from removal or depletion samplings (Leslie, DeLury, k-pass).\nR Script\nExercises\n\nMortality Rates\n\nEstimate total mortality rates from catch curve and capture-recapture data. Estimate fishing and natural mortality with empirical models.\nR Script and Data: CCatfishNB.csv, CutthroatAL.csv\nExercises\n\nIndividual Growth\n\nEstimate parameters for the von Bertalanffy growth function and compare growth parameters among populations.\nR Script and Data: BlackDrum2001.csv\nSupplements: Other VBGF Parameterizations, Other Growth Functions, Other Nonlinear Regression Algorithms\nExercises\n\nRecruitment\n\nEstimate parameters for the Beverton-Holt and Ricker stock-recruitment models, compute spawning potential ratios, and estimate year-class strengths from catch data.\nR Script and Data: PSalmonAK.csv, SturgeonGB.csv, WalleyeWad.csv, WalleyeWyrlng.csv\nSupplements: Maturity Schedules\nExercises"
  },
  {
    "objectID": "index.html#errata",
    "href": "index.html#errata",
    "title": "IFAR",
    "section": "Errata",
    "text": "Errata\nAn errata and post-production notes are maintained here."
  },
  {
    "objectID": "supplements/backcalculation.html",
    "href": "supplements/backcalculation.html",
    "title": "Backcalculation of Previous Lengths",
    "section": "",
    "text": "Note\n\n\n\nThe RFishBC package has functions to acquire growth increment data from images of ageing structures and to ease back-calculation computations. Please see the vignettes for RFishBC for a more thorough description of back-calculating previous lengths.\nFrancis (1990) defined back-calculation as “… a technique that uses a set of measurements made on a fish at one time to infer its length at an earlier time or times. Specifically, the dimensions of one or more marks in some hard part of the fish, together with its current body length, are used to estimate its length at the time of formation of each of the marks. … The marks are generally annual rings associated with growth checks, … .” Thus, backcalculation is the reconstruction of the length of a fish at previous ages from measurements made on calcified structures."
  },
  {
    "objectID": "supplements/backcalculation.html#packages",
    "href": "supplements/backcalculation.html#packages",
    "title": "Backcalculation of Previous Lengths",
    "section": "Packages",
    "text": "Packages\nFunctions used in this supplement require the following packages.\n\nlibrary(FSA)      # for peek(), headtail(), sumtable()\nlibrary(dplyr)    # for filter(), select(), mutate(), arrange(), group_by(), summarize()\n\nAlso note that single functions from the tidyr and stringr packages are used with :: so that the whole packages are not loaded here."
  },
  {
    "objectID": "supplements/backcalculation.html#data",
    "href": "supplements/backcalculation.html#data",
    "title": "Backcalculation of Previous Lengths",
    "section": "Data",
    "text": "Data\nAll analyses in this supplement use the West Bearskin Lake (MN) Smallmouth Bass (Micropterus dolomieu) data from Weisberg (1993) found in SMBassWB.1 The analysis in this supplement will focus on those fish captured in 1990. Three variables that were constant and not used in this analysis and three measurement variables that corresponded to ages that did not exist after reducing to only fish captured in 1990 were removed to save space.1 Download data with CSV link on the linked page.\n\nSMBassWB <- read.csv(\"https://raw.githubusercontent.com/fishR-Core-Team/FSA/main/data-raw/SMBassWB.csv\")\n\n\n\n\n\nwb90 <- SMBassWB |>\n  filter(yearcap==1990) |>\n  select(-(species:gear),-(anu10:anu12))\npeek(wb90,n=5)\n\n#R|      yearcap fish agecap lencap    anu1    anu2    anu3    anu4    anu5    anu6\n#R|  1      1990  482      1     75 1.51076      NA      NA      NA      NA      NA\n#R|  45     1990  431      3    130 1.01867 2.04110 3.22882      NA      NA      NA\n#R|  90     1990  453      3    165 1.63068 2.96180 3.96131      NA      NA      NA\n#R|  136    1990  382      7    225 1.33285 2.42372 3.04270 3.79372 4.86226 5.74919\n#R|  181    1990  389      9    329 1.05913 2.18769 3.55137 4.40766 5.78634 7.58178\n#R|         anu7    anu8     anu9   radcap\n#R|  1        NA      NA       NA  1.51076\n#R|  45       NA      NA       NA  3.22882\n#R|  90       NA      NA       NA  3.96131\n#R|  136 6.47536      NA       NA  6.47536\n#R|  181 8.32094 9.46362 10.43491 10.43491"
  },
  {
    "objectID": "supplements/backcalculation.html#scale-length-relationships",
    "href": "supplements/backcalculation.html#scale-length-relationships",
    "title": "Backcalculation of Previous Lengths",
    "section": "Scale-Length Relationships",
    "text": "Scale-Length Relationships\nThe scale-length (Equation 1) and length-scale (Equation 2) relationships required for all but the Dahl-Lea method are computed with the wide format data. Thus, the wide format data frame must contain the length of the fish (e.g., lencap) and the total radius of the calcified structure (e.g., radcap) at the time of capture. Both linear relationships are fit with lm() and the coefficients should be extracted with coef() and saved into objects.\n\nlm.sl <- lm(radcap~lencap,data=wb90)\n( a <- coef(lm.sl)[[1]] )\n\n#R|  [1] -1.304391\n\n( b <- coef(lm.sl)[[2]] )\n\n#R|  [1] 0.03537477\n\nlm.ls <- lm(lencap~radcap,data=wb90)\n( c <- coef(lm.ls)[[1]] )\n\n#R|  [1] 41.65166\n\n( d <- coef(lm.ls)[[2]] )\n\n#R|  [1] 27.35597"
  },
  {
    "objectID": "supplements/backcalculation.html#applying-the-back-calculation-models",
    "href": "supplements/backcalculation.html#applying-the-back-calculation-models",
    "title": "Backcalculation of Previous Lengths",
    "section": "Applying the Back-Calculation Models",
    "text": "Applying the Back-Calculation Models\nThe \\(L_{i}\\) estimated with a back-calculation model are most easily added to the long format data frame with mutate(). For example, the \\(L_{i}\\) computed with all four back-calculation models are added to wb90r below.\n\nwb90r <- wb90r |>\n  mutate(DL.len=(radi/radcap)*lencap,\n         FL.len=(radi/radcap)*(lencap-c)+c,\n         SPH.len=(-a/b)+(lencap+a/b)*(radi/radcap),\n         BPH.len=lencap*(c+d*radi)/(c+d*radcap))\nheadtail(wb90r,n=5)\n\n#R|      yearcap fish agecap lencap  radcap agei    radi    DL.len    FL.len\n#R|  1      1990  374      7    243 7.57375    1 1.01672  32.62096  68.68119\n#R|  2      1990  374      7    243 7.57375    2 2.39296  76.77693 105.26856\n#R|  3      1990  374      7    243 7.57375    3 3.47635 111.53696 134.07052\n#R|  4      1990  374      7    243 7.57375    4 4.37718 140.43964 158.01910\n#R|  5      1990  374      7    243 7.57375    5 5.18976 166.51087 179.62156\n#R|  763    1990  998      7    298 8.54805    3 3.60701 125.74669 149.82265\n#R|  764    1990  998      7    298 8.54805    4 4.48222 156.25804 176.06941\n#R|  765    1990  998      7    298 8.54805    5 5.17646 180.46047 196.88905\n#R|  766    1990  998      7    298 8.54805    6 6.62240 230.86847 240.25149\n#R|  767    1990  998      7    298 8.54805    7 8.54805 298.00000 298.00000\n#R|        SPH.len   BPH.len\n#R|  1    64.54444  67.83504\n#R|  2   102.00007 104.60001\n#R|  3   131.48552 133.54177\n#R|  4   156.00243 157.60660\n#R|  5   178.11753 179.31392\n#R|  763 147.06071 151.78969\n#R|  764 173.79670 177.68803\n#R|  765 195.00440 198.23129\n#R|  766 239.17509 241.01809\n#R|  767 298.00000 298.00000\n\n\nFor example, the mean length-at-age may be computed from the back-calculated lengths (shown below for the Fraser-Lee results).\n\nwb90r |>\n  group_by(agei) |>\n  summarize(n=validn(FL.len),mn=mean(FL.len),sd=sd(FL.len)) |>\n  as.data.frame()\n\n#R|    agei   n       mn        sd\n#R|  1    1 181  78.5663  6.472692\n#R|  2    2 178 114.1527 10.453632\n#R|  3    3 155 146.7669 13.898434\n#R|  4    4  71 172.6512 15.339848\n#R|  5    5  64 201.0405 17.479717\n#R|  6    6  64 235.3834 23.350527\n#R|  7    7  50 268.5969 25.286958\n#R|  8    8   2 283.2237 26.912010\n#R|  9    9   2 314.5000 20.506097\n\n\nAdditionally, the mean length at each back-calculated age computed separately for each age-at-capture may be computed with sumTable() from FSA, where the left side of the formula is the quantitative variable to be summarized and the right side has grouping variables presented in row*column format.\n\nsumTable(FL.len~agecap*agei,data=wb90r,digits=1)\n\n#R|       1     2     3     4     5     6     7     8     9\n#R|  1 73.7    NA    NA    NA    NA    NA    NA    NA    NA\n#R|  2 79.7 113.3    NA    NA    NA    NA    NA    NA    NA\n#R|  3 77.3 112.8 148.9    NA    NA    NA    NA    NA    NA\n#R|  4 71.3 121.8 160.9 194.0    NA    NA    NA    NA    NA\n#R|  6 79.8 107.9 136.0 169.6 198.8 229.7    NA    NA    NA\n#R|  7 81.6 118.2 144.7 170.7 201.8 237.0 269.1    NA    NA\n#R|  9 71.2  99.8 135.0 166.1 197.5 236.0 256.4 283.2 314.5"
  },
  {
    "objectID": "supplements/commonAxisLabels.html",
    "href": "supplements/commonAxisLabels.html",
    "title": "Common Axis Labels on a Grid of Subplots",
    "section": "",
    "text": "Several methods for modifying base graphics were shown in Ogle (2016), including simple layouts (side-by-side, one-over-the-other) of multiple plots. Creating common x- and y-axis labels for a grid of plots is described in this supplement. More complex layouts (e.g., plot in first row spans two columns or unequal sized plots) are described in this supplement.\nA single function is used from dplyr in this supplement; thus, :: is used instead of loading the entire package.\nThe BullTroutRML2 data from FSAdata used in Ogle (2016) are also used here.\n\ndata(BullTroutRML2,package=\"FSAdata\")\n\n\nCommon Axis Labels on a Grid of Subplots\nA common need is to plot multiple graphics in a grid-like format with one axis label that serves as the label for each graph. This can be accomplished with arguments to par(), but the regions of a plot must be understood first.\nEach plot consists of three regions – the plot area, the figure area, and the outer margin area (Figure 1). The plot area is where the points or bars will be graphed. The area between the plot area and the figure area is where the axis ticks, labels, and title will appear. The area outside of the figure area is the outer margin area and is generally used to provide extra space around the graphic or to place text.\n\n\n\n\n\nFigure 1: Schematic plot that illustrates the plotting area (inside the blue box), the figure area (inside the red box), and the outer margin area (between the dark gray and red boxes).\n\n\n\n\nIn most instances (and the default), the width of the outer margin area is 0 on all sides of the figure area such that no outer margin area exists. The size of the outer margin area is set with oma= in par(), which takes a vector of four values to serve as widths of the four sides of the outer margin area, beginning with the bottom and moving counter-clockwise. The default is par(oma=c(0,0,0,0)). For example, margins that are two “lines” wide on the top and bottom and one “line” wide on the left and right may be set with par(oma=c(2,1,2,1)).\nCommon axis labels for multiple graphs can be placed in the outer margin area. In the example below, a 2-by-2 grid is created with mfrow() (as described in Ogle (2016)) and the bottom and left outer margin areas are increased to be two “lines” wide to allow for common x- and y-axis labels.\n\npar(mfrow=c(2,2),oma=c(2,2,0,0))\n\nThe four subplot areas are then populated with scatterplots (note that the x- and y-axis labels are set to empty strings to suppress labeling the axes)\n\nxlmts <- c(-0.5,14.5)\nylmts <- c(0,700)\nBTH1 <- BullTroutRML2 |> dplyr::filter(lake==\"Harrison\",era==\"1977-80\")\nplot(fl~age,data=BTH1,main=\"Harrison, 1977-80\",\n     xlab=\"\",ylab=\"\",pch=19,xlim=xlmts,ylim=ylmts)\nBTO1 <- BullTroutRML2 |> dplyr::filter(lake==\"Osprey\",era==\"1977-80\")\nplot(fl~age,data=BTO1,main=\"Osprey, 1977-80\",\n     xlab=\"\",ylab=\"\",pch=19,xlim=xlmts,ylim=ylmts)\nBTH2 <- BullTroutRML2 |> dplyr::filter(lake==\"Harrison\",era==\"1997-01\")\nplot(fl~age,data=BTH2,main=\"Harrison, 1997-01\",\n     xlab=\"\",ylab=\"\",pch=19,xlim=xlmts,ylim=ylmts)\nBTO2 <- BullTroutRML2 |> dplyr::filter(lake==\"Osprey\",era==\"1997-01\")\nplot(fl~age,data=BTO2,main=\"Osprey, 1997-01\",\n     xlab=\"\",ylab=\"\",pch=19,xlim=xlmts,ylim=ylmts)\n\nThe common x- and y-axis labels are then placed in the outer margin areas with mtext(). In this capacity, mtext() requires the text to be written as the first argument, a number in side= that indicates the margin on which to print the text,1 a number in line= that indicates the line on which to print the text (defaults to 0), and outer=TRUE to force the text into the outer margin area. Further note that las=0 is used for the y-axis label to force the text to be parallel to the y-axis. This is only needed because las=1 was set globally for producing this supplement.1 The side= argument in mtext() uses the same numbering scheme as other functions – 1=bottom, 2=left, 3=top, 4=right.\n\nmtext(\"Age (years)\",side=1,line=0,outer=TRUE,cex=1.3)\nmtext(\"Fork Length (mm)\",side=2,line=0,outer=TRUE,cex=1.3,las=0)\n\nThe combined code above creates the plot shown in Figure 2.\n\n\n\n\n\nFigure 2: Grid of plots that uses the outer margin area to provide common axis labels.\n\n\n\n\n\n\n\n\n\n\nReferences\n\nOgle, D. H. 2016. Introductory Fisheries Analyses with R. CRC Press, Boca Raton, FL."
  },
  {
    "objectID": "supplements/complexGridLayouts.html",
    "href": "supplements/complexGridLayouts.html",
    "title": "Complex Grid Layouts",
    "section": "",
    "text": "Several methods for modifying base graphics were shown in Ogle (2016), including simple layouts (side-by-side, one-over-the-other) of multiple plots. More complex layouts (e.g., plot in first row spans two columns or unequal sized plots) are described in this supplement. Creating common x- and y-axis labels for a grid of plots is described in this supplement.\nA single function is used from dplyr in this supplement; thus, :: is used instead of loading the entire package. The FSA package is loaded here to provide access to the modified hist().\n\nlibrary(FSA)\n\nThe BullTroutRML2 and BloaterLH data from FSAdata used in Ogle (2016) are also used here.\n\ndata(BullTroutRML2,package=\"FSAdata\")\ndata(BloaterLH,package=\"FSAdata\")\n\n\nComplex Grid Layouts with layout()\nThe layout() function allows for more complicated organizations of plots. The only required argument to layout() is a matrix that specifies the positions, as a grid, for a series of plots. The numbers in the matrix describe which sequential plot will appear in that position. For example, the following code constructs a 2x2 grid for four plots where the first plot will appear in the lower-right corner and the last (fourth) plot will appear in the upper-left corner.\n\n( m <- matrix(4:1,nrow=2,byrow=TRUE) )\n\n#R|       [,1] [,2]\n#R|  [1,]    4    3\n#R|  [2,]    2    1\n\nlayout(m)\n\nThe layout.show() function is used to show the layout grid. Its only argument is the number of positions to show. The example below illustrates the layout created above.\n\nlayout.show(4)\n\n\n\n\nFigure 1: Illustration of 2x2 layout grid for graphics.\n\n\n\n\nThe 2x2 grid in Figure 1 is not that interesting because that layout is just as easily constructed with mfrow= in par() (as shown in the IFAR book). Layouts, however, can also be constructed that are not “grids.” For example, the entire first row may be one plot with a second row of two plots. This layout grid is constructed by including a “1” in the first two positions of the layout matrix (Figure 2).\n\n( m <- matrix(c(1,1,2,3),nrow=2,byrow=TRUE) )\n\n#R|       [,1] [,2]\n#R|  [1,]    1    1\n#R|  [2,]    2    3\n\nlayout(m)\n\n\nlayout.show(3)\n\n\n\n\nFigure 2: Illustration of layout grid for graphics with one plot in the first row and two in the second row.\n\n\n\n\nThe following code fills this layout grid to produce Figure 3.\n\npar(mar=c(3.05,3.05,0.65,0.65),mgp=c(1.9,0.3,0),tcl=-0.2,las=1,\n    cex.lab=0.95,cex.axis=0.9)\nplot(age3~eggs,data=BloaterLH,pch=19,xlab=\"Millions of Eggs\",\n     ylab=\"Relative Abundance of Age-3 Fish\")\nhist(~eggs,data=BloaterLH,xlab=\"Millions of Eggs\")\nhist(~age3,data=BloaterLH,xlab=\"Age-3 Relative Abundance\")\n\n\n\n\nFigure 3: Illustration of a plot with one subplot in the first row and two in the second row.\n\n\n\n\n \nThe size of the plots in the layout may be controlled with height= and width=. These arguments accept vectors that represent the relative heights and widths of the rows and columns in the layout grid, respectively. For example, height=c(3,1) sets the height of the first row to be three times larger than the height of the second row. Including the respect=TRUE argument will assure that “unit distances” in the horizontal and vertical directions are treated the same. An example layout with different cell sizes is constructed below and shown in Figure 4. Also note in this example, that a zero in a cell means that that cell will not receive a plot.\n\n( m <- matrix(c(2,0,1,3),nrow=2,byrow=TRUE) )\n\n#R|       [,1] [,2]\n#R|  [1,]    2    0\n#R|  [2,]    1    3\n\nlayout(m,height=c(1,4),width=c(4,1),respect=TRUE)\n\n\nlayout.show(3)\n\n\n\n\nFigure 4: Illustration of layout grid for plots with differing row heights and column widths.\n\n\n\n\nFigure 5 is an example that fills the layout shown in Figure 4.\n\npar(mar=c(4,4,0,0))\nplot(age3~eggs,data=BloaterLH,xlim=c(0,2.4),ylim=c(0,240),pch=19,\n     ylab=\"Relative Abundance of Age-3 Fish\",\n     xlab=\"Millions of Eggs\")\npar(mar=c(0,4,0,0))\nboxplot(BloaterLH$eggs,axes=FALSE,ylim=c(0,2.4),horizontal=TRUE)\npar(mar=c(4,0,0,0))\nboxplot(BloaterLH$age3,axes=FALSE,ylim=c(0,240))\n\n\n\n\nFigure 5: Illustration of layout grid with differing heights and widths such that a scatterplot appears in the ‘middle’ with corresponding boxplots on the ‘sides.’\n\n\n\n\n \nFinally, layout() may be used to make quite complex grids, as illustrated with the code below that produced Figure 6. Note that plot.new() creates a new blank plot in which the subsequent text() commands will place text (in this case marginal labels).\n\nBTH1 <- BullTroutRML2 |> dplyr::filter(lake==\"Harrison\",era==\"1977-80\")\nBTO1 <- BullTroutRML2 |> dplyr::filter(lake==\"Osprey\",era==\"1977-80\")\nBTH2 <- BullTroutRML2 |> dplyr::filter(lake==\"Harrison\",era==\"1997-01\")\nBTO2 <- BullTroutRML2 |> dplyr::filter(lake==\"Osprey\",era==\"1997-01\")\n\n( m <- matrix(c(0,1,2,3,5,6,4,7,8),nrow=3,byrow=TRUE) )\n\n#R|       [,1] [,2] [,3]\n#R|  [1,]    0    1    2\n#R|  [2,]    3    5    6\n#R|  [3,]    4    7    8\n\nlayout(m,height=c(1,8,8),width=c(1,8,8),respect=TRUE)\n\npar(mar=c(0,0,0,0))\nplot.new(); text(0.5,0.5,\"Harrison\",cex=1.5)\nplot.new(); text(0.5,0.5,\"Osprey\",cex=1.5)\nplot.new(); text(0.5,0.5,\"Era = 1977-1980\",cex=1.5,srt=90)\nplot.new(); text(0.5,0.5,\"Era = 1997-2001\",cex=1.5,srt=90)\n\npar(mar=c(3.05,3.05,0.65,0.65),mgp=c(1.7,0.5,0))\nxlmt <- c(-0.5,14.5)\nylmt <- c(0,700)\nplot(fl~age,data=BTH1,xlab=\"\",ylab=\"Fork Length\",\n     pch=19,xlim=xlmt,ylim=ylmt)\nplot(fl~age,data=BTO1,xlab=\"\",ylab=\"\",\n     pch=19,xlim=xlmt,ylim=ylmt)\nplot(fl~age,data=BTH2,xlab=\"Age\",ylab=\"Fork Length\",\n     pch=19,xlim=xlmt,ylim=ylmt)\nplot(fl~age,data=BTO2,xlab=\"Age\",ylab=\"\",\n     pch=19,xlim=xlmt,ylim=ylmt)\n\n\n\n\nFigure 6: Illustration of layout grid with differing heights and widths such that labels can be placed on the sides.\n\n\n\n\n\n\n\n\n\nReferences\n\nOgle, D. H. 2016. Introductory Fisheries Analyses with R. CRC Press, Boca Raton, FL."
  },
  {
    "objectID": "supplements/otherGrowthFuns.html",
    "href": "supplements/otherGrowthFuns.html",
    "title": "Other Growth Functions",
    "section": "",
    "text": "The von Bertalanffy Growth Function (VBGF) was introduced and methods for fitting the function were illustrated in Chapter 12 of Ogle (2016). Mean length-at-age has been modeled by functions other than the VBGF. Common other functions are the exponential, logistic, and polynomial (Ricker 1975), as well as the specific functions of Gompertz (1825), Richards (1959), and Schnute (1981).\nSeveral of these functions are used in this supplement to demonstrate how to fit growth functions other than the VBGF. Other supplements demonstrate how to fit other parameterizations of the VBGF and use alternative nonlinear model fitting algorithms."
  },
  {
    "objectID": "supplements/otherGrowthFuns.html#packages",
    "href": "supplements/otherGrowthFuns.html#packages",
    "title": "Other Growth Functions",
    "section": "Packages",
    "text": "Packages\nFunctions used in this supplement require the following packages. Also note that one function from AICcmodavg is used below with :: so that the whole package does not have to be loaded.\n\nlibrary(FSA)        # for headtail(), vbFuns(), vbStarts()\nlibrary(dplyr)      # for select(), filter()\nlibrary(nlstools)   # for nlsBoot()"
  },
  {
    "objectID": "supplements/otherGrowthFuns.html#data",
    "href": "supplements/otherGrowthFuns.html#data",
    "title": "Other Growth Functions",
    "section": "Data",
    "text": "Data\nThe male Black Drum data.1 used in Ogle (2016) are also used in this supplement. As in Ogle (2016) a few unneeded variables are removed for simplicity, only males are examined, and a single old fish is removed by including only fish with an otolith age less than 50.1 Download data with CSV link on the linked page.\n\nbdm <- read.csv(\"https://raw.githubusercontent.com/fishR-Core-Team/FSAdata/main/data-raw/BlackDrum2001.csv\") |>\n  select(-c(spname,day,weight)) |>\n  filter(sex==\"male\",otoage<50)\nheadtail(bdm)\n\n#R|     year agid month     tl  sex otoage\n#R|  1  2001    1     4  787.5 male      6\n#R|  2  2001    2     5  700.0 male      5\n#R|  3  2001    8     5 1140.0 male     23\n#R|  72 2001  122     5 1175.0 male     39\n#R|  73 2001  125     6  590.0 male      4\n#R|  74 2001  127     6  530.0 male      3"
  },
  {
    "objectID": "supplements/otherNLAlgorithms.html",
    "href": "supplements/otherNLAlgorithms.html",
    "title": "Other Nonlinear Model Fitting Algorithms",
    "section": "",
    "text": "The von Bertalanffy Growth Function (VBGF) was introduced and methods for fitting the function were illustrated in Chapter 12 of Ogle (2016). The nls() function demonstrated in the IFAR book uses the Gauss-Newton algorithm by default. However, there are many other algorithms for fitting nonlinear functions. Two of the several algorithms coded in R are demonstrated in this supplement."
  },
  {
    "objectID": "supplements/otherNLAlgorithms.html#packages",
    "href": "supplements/otherNLAlgorithms.html#packages",
    "title": "Other Nonlinear Model Fitting Algorithms",
    "section": "Packages",
    "text": "Packages\nFunctions used in this supplement require the following packages.\n\nlibrary(FSA)        # for headtail(), vbFuns(), vbStarts()\nlibrary(dplyr)      # for select(), filter()\nlibrary(nlstools)   # for nlsBoot()\nlibrary(minpack.lm) # for nlsLM()"
  },
  {
    "objectID": "supplements/otherNLAlgorithms.html#data",
    "href": "supplements/otherNLAlgorithms.html#data",
    "title": "Other Nonlinear Model Fitting Algorithms",
    "section": "Data",
    "text": "Data\nThe male Black Drum data.1 used in Ogle (2016) are also used in this supplement. As in Ogle (2016) a few unneeded variables are removed for simplicity, only males are examined, and a single old fish is removed by including only fish with an otolith age less than 50.1 Download data with CSV link on the linked page.\n\nbdm <- read.csv(\"https://raw.githubusercontent.com/fishR-Core-Team/FSAdata/main/data-raw/BlackDrum2001.csv\") |>\n  select(-c(spname,day,weight)) |>\n  filter(sex==\"male\",otoage<50)\nheadtail(bdm)\n\n#R|     year agid month     tl  sex otoage\n#R|  1  2001    1     4  787.5 male      6\n#R|  2  2001    2     5  700.0 male      5\n#R|  3  2001    8     5 1140.0 male     23\n#R|  72 2001  122     5 1175.0 male     39\n#R|  73 2001  125     6  590.0 male      4\n#R|  74 2001  127     6  530.0 male      3"
  },
  {
    "objectID": "supplements/otherVBGFParams.html",
    "href": "supplements/otherVBGFParams.html",
    "title": "Other VBGF Parameterizations",
    "section": "",
    "text": "The von Bertalanffy Growth Function (VBGF) was introduced and methods for fitting the function were illustrated in Chapter 12 of Ogle (2016). The VBGF used there is from Beverton and Holt (1957) and is called the “Typical” parameterization of the VBGF. The VBGF can be expressed in alternative forms that are called parameterizations.\nDifferent parameterizations do not fit the data differently. In other words, all parameterizations of the VBGF have the same number of parameters and will produce the same predicted values and fitted model plots. However, different parameterizations have different function parameters that may be of interest to the fisheries scientist for biological reasons or because they have useful statistical properties. For example, the parameterizations of von Bertalanffy (1938) and Mooij et al. (1999) both use \\(L_{0}\\), which is the mean length at time 0 (i.e., at “hatch”). Thus, either of these parameterizations could be used if the \\(L_{0}\\) parameter was of biological interest. In contrast, the parameters in the parameterizations of Schnute (1981) and Francis (1988) are either largely or wholly based on expected values, which are generally less correlated. Thus, if one wants to avoid the problems associated with highly correlated parameters (as discussed Ogle (2016)) and is not interested in the parameters of the other parameterizations, then either of these two parameterizations may be used.\nThe parametarizations of von Bertalanffy (1938) and Francis (1988) are fit in this supplement to illustrate fitting other than the “Typical” parameterization used in Chapter 12 of Ogle (2016). Other supplements demonstrate how to fit growth functions other than the VBGF and use alternative nonlinear model fitting algorithms."
  },
  {
    "objectID": "supplements/otherVBGFParams.html#packages",
    "href": "supplements/otherVBGFParams.html#packages",
    "title": "Other VBGF Parameterizations",
    "section": "Packages",
    "text": "Packages\nFunctions used in this supplement require the following packages.\n\nlibrary(FSA)      # for headtail(), vbFuns(), vbStarts()\nlibrary(dplyr)    # for select(), filter()\nlibrary(nlstools) # for nlsBoot()"
  },
  {
    "objectID": "supplements/otherVBGFParams.html#data",
    "href": "supplements/otherVBGFParams.html#data",
    "title": "Other VBGF Parameterizations",
    "section": "Data",
    "text": "Data\nThe male Black Drum data.1 used in Ogle (2016) are also used in this supplement. As in Ogle (2016) a few unneeded variables are removed for simplicity, only males are examined, and a single old fish is removed by including only fish with an otolith age less than 50.1 Download data with CSV link on the linked page.\n\nbdm <- read.csv(\"https://raw.githubusercontent.com/fishR-Core-Team/FSAdata/main/data-raw/BlackDrum2001.csv\") |>\n  select(-c(spname,day,weight)) |>\n  filter(sex==\"male\",otoage<50)\nheadtail(bdm)\n\n#R|     year agid month     tl  sex otoage\n#R|  1  2001    1     4  787.5 male      6\n#R|  2  2001    2     5  700.0 male      5\n#R|  3  2001    8     5 1140.0 male     23\n#R|  72 2001  122     5 1175.0 male     39\n#R|  73 2001  125     6  590.0 male      4\n#R|  74 2001  127     6  530.0 male      3"
  },
  {
    "objectID": "supplements/maturity.html",
    "href": "supplements/maturity.html",
    "title": "Maturity Analyses",
    "section": "",
    "text": "The length-, weight-, or age-at-maturity is important to monitor for fish populations because these metrics are closely tied to reproductive potential and respond to changes in inter- and intra-specific densities and resource availability (Pope et al. 2010). Methods for modeling the relationship between maturity stage and length is demonstrated in this supplement. Results from these modeled relationships are then used to calculate metrics such as length at 50% maturity. These methods extend directly to use with age or weight data."
  },
  {
    "objectID": "supplements/maturity.html#packages",
    "href": "supplements/maturity.html#packages",
    "title": "Maturity Analyses",
    "section": "Packages",
    "text": "Packages\nFunctions used in this supplement require the following packages. Also note that one function from lubridate and two functions from car are used below with :: so that the whole packages do not need to be loaded.\n\nlibrary(FSA)      # for headtail()\nlibrary(dplyr)    # for select(), mutate(), filter()"
  },
  {
    "objectID": "supplements/maturity.html#data",
    "href": "supplements/maturity.html#data",
    "title": "Maturity Analyses",
    "section": "Data",
    "text": "Data\nThe total length (length; to the nearest cm), age (years), and maturity (Immature and Mature) state of female Yelloweye Rockfish (Sebastes rubberimus) collected from along the Oregon coast are recorded in YERockFish.csv.1 The stage variable was removed to minimize output below.1 Download data with CSV link on the linked page.\n\ndf <- read.csv(\"https://raw.githubusercontent.com/fishr-core-team/FSAdata/master/data-raw/YERockfish.csv\") |>\n  select(-stage)\nstr(df)\n\n#R|  'data.frame':  158 obs. of  4 variables:\n#R|   $ date    : chr  \"9/2/2003\" \"10/7/2002\" \"7/18/2000\" \"6/11/2001\" ...\n#R|   $ length  : int  31 32 32 32 32 33 33 34 34 34 ...\n#R|   $ age     : int  10 6 11 11 13 9 10 8 10 11 ...\n#R|   $ maturity: chr  \"Immature\" \"Immature\" \"Immature\" \"Immature\" ...\n\nheadtail(df)\n\n#R|           date length age maturity\n#R|  1    9/2/2003     31  10 Immature\n#R|  2   10/7/2002     32   6 Immature\n#R|  3   7/18/2000     32  11 Immature\n#R|  156 8/18/2002     67  50   Mature\n#R|  157 10/7/2002     68  88   Mature\n#R|  158 4/23/2001     70  66   Mature\n\n\nFor use with glm() below, the maturity variable must be a factor variable, not the character variable that it is currently in df. Variables may be converted to factors with factor(). I use levels= to make sure that the level that represents “being mature” is listed second.22 By default, the levels are created in alphabetical order, which would have worked correctly in this case.\n\ndf <- df |>\n  mutate(maturity=factor(maturity,levels=c(\"Immature\",\"Mature\")))\n\nThe date of capture was also recorded. A new variable that indicates whether the fish was captured before 2002 or in 2002 and after is needed for use in a later example that compares the relationship between maturity and length between two groups. This conversion requires that date be converted to a format that R will recognize as a date. The as.POSIXct() function does this conversion, taking the original dates as its first argument. Additionally, a string is given to format= that describes the format of the dates in the original variable. The codes that may be used in this string are described in ?strptime. Common codes used with fisheries data are\n\n%m: month as a number,\n%b: month as an abbreviated name (e.g., Jan, Feb),\n%d: day of the month,\n%Y: four-digit year (e.g., 2015), and\n%y: two-digit (i.e., without the century) year (e.g., 15).\n\nThese format codes are separated by the characters that separate the fields in the original date variable (e.g., /, -).\nAn examination of date above shows that the dates are in month as a number, day of the month, and four digit year format separated by “forward slashes.” Thus, date is converted below to a date format that R will recognize.\n\ndf <- df |>\n  mutate(date=as.POSIXct(date,format=\"%m/%d/%Y\"))\nstr(df)\n\n#R|  'data.frame':  158 obs. of  4 variables:\n#R|   $ date    : POSIXct, format: \"2003-09-02\" \"2002-10-07\" ...\n#R|   $ length  : int  31 32 32 32 32 33 33 34 34 34 ...\n#R|   $ age     : int  10 6 11 11 13 9 10 8 10 11 ...\n#R|   $ maturity: Factor w/ 2 levels \"Immature\",\"Mature\": 1 1 1 1 1 1 1 1 1 1 ...\n\n\nThe year of capture may then be extracted from date with year() from lubridate. Note that the month could be extracted with month(), day of the month with mday(), and day of the year (1-366) with yday(). A variable (era) that indicates the era (pre-2002 or 2002 and after) is then added to the data frame as a factor.\n\ndf <- df |>\n  mutate(year=lubridate::year(date),\n         era=ifelse(year<2002,\"pre-2002\",\"2002 and after\"),\n         era=factor(era,levels=c(\"pre-2002\",\"2002 and after\")))\nheadtail(df)\n\n#R|            date length age maturity year            era\n#R|  1   2003-09-02     31  10 Immature 2003 2002 and after\n#R|  2   2002-10-07     32   6 Immature 2002 2002 and after\n#R|  3   2000-07-18     32  11 Immature 2000       pre-2002\n#R|  156 2002-08-18     67  50   Mature 2002 2002 and after\n#R|  157 2002-10-07     68  88   Mature 2002 2002 and after\n#R|  158 2001-04-23     70  66   Mature 2001       pre-2002\n\n\nFinally, maturity was not recorded for several individuals, which were removed from further analysis.\n\ndf <- df |>\n  filter(!is.na(maturity))"
  },
  {
    "objectID": "supplements/maturity.html#fitting-the-logistic-regression-model",
    "href": "supplements/maturity.html#fitting-the-logistic-regression-model",
    "title": "Maturity Analyses",
    "section": "Fitting the Logistic Regression Model",
    "text": "Fitting the Logistic Regression Model\nRaw maturity data is generally summarized with a logistic regression. A logistic regression is conducted with a binomial response variable and, generally, a quantitative explanatory variable. The relationship between the probability of “success” (\\(p\\)) and the explanatory variable (length or age) is generally not linear (primarily due to the constraint that the probability is between 0 and 1). This relationship can be linearized by first transforming \\(p\\) to the odds (i.e., \\(\\frac{p}{1-p}\\)). The odds related the probability of “successes” to “failures.” For example, an odds of 1 indicates that there is an equal probability of success and failure, whereas an odds of 3 indicates that the probability of success is three times the probability of failure.\nThe transformation to a linear relationship is completed by computing the logarithm of the odds (i.e., \\(log(\\frac{p}{1-p})\\)). The complete transformation from \\(p\\) to \\(log(\\frac{p}{1-p})\\) is called the logit transformation.\nThus, the linear model in a logistic regression models the log odds as a function of an explanatory variable, \\(X\\), with\n\\[ log\\left(\\frac{p}{1-p}\\right) = \\alpha + \\beta_{1}X  \\tag{1}\\]\nIn maturity analyses, the logistic regression is used to model the log odds of being mature as a function of either length or age. It will be shown later in this supplement how the log odds of being mature are back-transformed to the probability of being mature.\nLogistic regressions are fit with glm(), rather than the lm() used in Ogle (2016). For a logistic regression the first argument to glm() is a formula of the form factor~quant where factor and quant generically represent factor and quantitative variables, respectively. The data.frame that contains factor and quant is given to data=. Finally, glm() is forced to use the logit transformation and fit a logistic regression by including family=binomial. For example, the glm() code below will model the log odds of being mature as a function of the length of the Rockfish.\n\nglm1 <- glm(maturity~length,data=df,family=binomial)\n\nParameter estimates are extracted from the glm() object with coef(). Confidence intervals for the parameters of a logistic regression are best estimated with bootstrapping (rather than normal theory). Bootstrapping is performed with bootCase() from car as described in Chapter 12 of Ogle (2016).\n\nbcL <- car::Boot(glm1)\ncbind(Ests=coef(glm1),confint(bcL))\n\n#R|                     Ests       2.5 %      97.5 %\n#R|  (Intercept) -16.9482593 -24.6251636 -10.9477496\n#R|  length        0.4371786   0.2902476   0.6247417\n\n\nThe estimated slope indicates that a 1 cm increase in the length of the Yelloweye Rockfish will result in a 0.437 increase in the log odds that the Rockfish is mature. Changes in log odds are difficult to interpret. However, the back-transformed slope is interpreted as a multiplicative change in the odds of being mature. For example, a 1 cm increase in the length of the Yelloweye Rockfish will result in a 1.548 (i.e., \\(e^{0.437}\\)) times increase in the odds that the Rockfish is mature."
  },
  {
    "objectID": "supplements/maturity.html#predicted-probability-of-being-mature",
    "href": "supplements/maturity.html#predicted-probability-of-being-mature",
    "title": "Maturity Analyses",
    "section": "Predicted Probability of Being Mature",
    "text": "Predicted Probability of Being Mature\nThe probability of a fish being mature given the observed value of the explanatory variable (\\(x\\)) can be computed by solving Equation 1 for \\(p\\),\n\\[ p = \\frac{e^{\\alpha + \\beta_{1}x}}{1+e^{\\alpha + \\beta_{1}}}  \\tag{2}\\]\nThis prediction is computed with predict(), which requires the glm() object as the first argument, a data.frame with the values of the explanatory variable for which to make the prediction as the second argument, and type=\"response\" (which forces the prediction of the probability, rather than the log odds, of being mature). For example, the predicted probabilities of being mature for female Yelloweye Rockfish that are 32- and 42-cm total length are computed below.\n\npredict(glm1,data.frame(length=c(32,42)),type=\"response\")\n\n#R|          1         2 \n#R|  0.0493342 0.8042766\n\n\nConfidence intervals for the predicted probability are formed by computing the prediction for each bootstrap sample and then extracting the values for the upper and lower 2.5% of these predictions. This process is most easily accomplished by forming a function that represents Equation 2 and then using apply() to apply that function to each row of the matrix containing the bootstrap samples. This is the same process as described in Chapter 12 of Ogle (2016). The code below computes the 95% confidence intervals for the predicted probability of being mature for 32 cm long Yelloweye Rockfish.33 Note here that the results of each bootstrapped sample are in t of the Boot() object (i.e., bcL).\n\npredP <- function(cf,x) exp(cf[1]+cf[2]*x)/(1+exp(cf[1]+cf[2]*x))\np32 <- apply(bcL$t,1,predP,x=32)\nquantile(p32,c(0.025,0.975))\n\n#R|         2.5%       97.5% \n#R|  0.005181076 0.138317023\n\n\nThus, the probability that a 32 cm Yelloweye Rockfish is mature is between 0.005 and 0.138."
  },
  {
    "objectID": "supplements/maturity.html#a-summary-plot",
    "href": "supplements/maturity.html#a-summary-plot",
    "title": "Maturity Analyses",
    "section": "A Summary Plot",
    "text": "A Summary Plot\nA plot that illustrates the fit of the logistic regression (Figure 2) is constructed in several steps. First, a base plot that depicts the raw data is constructed. Take special note here that maturity is forced to be numeric between 0 and 1 for the plot and transparent points (as described in Chapter 3 of Ogle (2016)) are used because there is considerable overplotting with the “discrete” maturity and length data.\n\nplot((as.numeric(maturity)-1)~length,data=df,\n     pch=19,col=rgb(0,0,0,1/8),\n     xlab=\"Total Length (cm)\",ylab=\"Proportion Mature\")\n\nSecond, points that represent the proportion mature for each 2-cm length bin are added to the plot with points() (recall that the summaries in props were constructed above). Note that pch=3 plots the points as “plus signs.”\n\npoints(props[,\"Mature\"]~as.numeric(rownames(props)),pch=3)\n\nFinally, the fitted line from the logistic regression is added by first using the glm() object to predict the probability of being mature for lengths that span the range of observed lengths and then plotting these values as a line with lines().\n\nlens <- seq(30,70,length.out=199)\npreds <- predict(glm1,data.frame(length=lens),type=\"response\")\nlines(preds~lens,lwd=2)\n\n\n\n\n\n\nFigure 2: Fitted logistic regression for the proportion of female Yelloweye Rockfish that are mature by total length."
  },
  {
    "objectID": "supplements/maturity.html#length--or-age-at-maturity",
    "href": "supplements/maturity.html#length--or-age-at-maturity",
    "title": "Maturity Analyses",
    "section": "Length- or Age-at-Maturity",
    "text": "Length- or Age-at-Maturity\nA common metric in fisheries science is to find the length or age at which a certain percentage of fish are mature. For example, it is common to ask “what is the length or age at which 50% of the fish have reached maturity?” A general formula for computing this metric is found by solving Equation 1 for \\(X\\),\n\\[ x = \\frac{log\\left(\\frac{p}{1-p}\\right)-\\alpha}{\\beta_{1}}  \\tag{3}\\]\nIn the common case of finding \\(X\\) for 50% maturity (i.e., \\(p=0.5\\)), Equation 3 reduces to\n\\[ x = -\\frac{\\alpha}{\\beta_{1}}  \\tag{4}\\]\nThe age at which 50% of the fish are mature is commonly symbolized as \\(A_{50}\\). Similarly, the length at which 90% of the fish are mature would be \\(L_{90}\\).\nThese calculations are simplified by creating a function to perform Equation 3.\n\nlrPerc <- function(cf,p) (log(p/(1-p))-cf[[1]])/cf[[2]]\n\nThis functions takes the coefficents from the glm() object as the first argument and the probability of interest (\\(p\\)) as the second argument. As examples, the lengths at which 50% and 90% of the female Yelloweye Rockfish are mature are computed below.\n\n( L50 <- lrPerc(coef(glm1),0.5) )\n\n#R|  [1] 38.76736\n\n( L90 <- lrPerc(coef(glm1),0.9) )\n\n#R|  [1] 43.79328\n\n\nConfidence intervals for these values are constructed from the bootstrap samples, similar to what was illustrated above for predicted values.\n\nbL50 <- apply(bcL$t,1,lrPerc,p=0.5)\n( L50ci <- quantile(bL50,c(0.025,0.975)) )\n\n#R|      2.5%    97.5% \n#R|  37.33720 40.20835\n\nbL90 <- apply(bcL$t,1,lrPerc,p=0.9)\n( L90ci <- quantile(bL90,c(0.025,0.975)) )\n\n#R|      2.5%    97.5% \n#R|  41.64754 45.78287\n\n\nThus, for example, the predicted length at which 50% of the Yelloweye Rockfish are mature is between 37.3 and 40.2, with 95% confidence.\nThe calculation of the \\(L_{50}\\) may be illustrated on a fitted-line plot (Figure 3) by adding the code below to the code used above to construct Figure 2.\n\nlines(c(0,L50),c(0.5,0.5),lty=2,lwd=2,col=\"red\")\nlines(c(L50,L50),c(-0.2,0.5),lty=2,lwd=2,col=\"red\")\n\n\n\n\n\n\nFigure 3: Fitted logistic regression for the proportion of female Yelloweye Rockfish that are mature by total length with \\(L_{50}\\) shown."
  },
  {
    "objectID": "supplements/maturity.html#model-fitting",
    "href": "supplements/maturity.html#model-fitting",
    "title": "Maturity Analyses",
    "section": "Model Fitting",
    "text": "Model Fitting\nIt may be important to determine if the fit of the logistic regression differs between two groups. For example, one may need to determine if the logistic regression parameters differ significantly between fish captured “pre-2002” and those captured in “2002 and after” (recall that these two “eras” are recorded in era in df).\nThe model required to answer this type of question is a logistic regression version of the dummy variable regression introduced in Chapter 7 of Ogle (2016). Specifically, the right side of the formula in glm() is modified to be quant*factor where quant is the covariate (usually length or age) and factor is the factor variable that identifies the groups being compared. As noted in Chapter 7 of Ogle (2016), this formula is actually shorthand for a model with three terms – quant and factor main effects and the interaction between the quant and factor variables. In this case, the model is fit as shown below.\n\nglm3 <- glm(maturity~length*era,data=df,family=binomial)\n\nThe significance of terms in a general linear model are computed with a chi-square distribution and summarized in an “Analysis of Deviance Table”, rather than with an F distribution and ANOVA table as with a linear model. Fortunately, the Analysis of Deviance table using Type II tests is also retrieved with Anova() from car.\n\ncar::Anova(glm3)\n\n#R|  Analysis of Deviance Table (Type II tests)\n#R|  \n#R|  Response: maturity\n#R|             LR Chisq Df Pr(>Chisq)    \n#R|  length       68.599  1    < 2e-16 ***\n#R|  era           0.005  1    0.94541    \n#R|  length:era    3.100  1    0.07831 .  \n#R|  ---\n#R|  Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAs with the ANOVA table in a dummy variable regression, the Analysis of Deviance table should be read from the bottom. In this case, the interaction term is not signficant which suggests that the slopes for the logit-transformed models do not differ between the eras. The era main effect is also not signficant, which suggests that the y-intercepts for the logit-transformed models do not differ between the eras. Thus, there is no signficant difference in the logistic regressions between fish captured in the two eras."
  },
  {
    "objectID": "supplements/maturity.html#comparing-lengths--or-ages-at-maturity",
    "href": "supplements/maturity.html#comparing-lengths--or-ages-at-maturity",
    "title": "Maturity Analyses",
    "section": "Comparing Lengths- or Ages-at-Maturity",
    "text": "Comparing Lengths- or Ages-at-Maturity\nA p-value for testing whether the \\(L_{50}\\) differed between groups may be computed from the bootstrapped samples. However, this calculation requires several steps and a good understanding of the parameter estimates from the logistic regression model fit to both groups. Thus, the steps and the parameter estimates are described further below.\nBefore building the hypothesis test, lets examine the parameter estimates for the logistic regression model.\n\ncoef(glm3)\n\n#R|               (Intercept)                   length        era2002 and after \n#R|               -27.1314345                0.6956840               14.0137840 \n#R|  length:era2002 and after \n#R|                -0.3510082\n\n\nNote that the parameter estimates under the (Intercept) and length headings are the intercept and slope, respectively, for the “reference” group in the model. The reference group is the alphabetically first group, unless the levels of the factor variable were changed by the user as was done in this supplement. The order of the levels can be observed with str() or levels().\n\nlevels(df$era)\n\n#R|  [1] \"pre-2002\"       \"2002 and after\"\n\n\nThus, the estimated intercept and slope of the logistic regression for the “pre-2002” era fish are -27.131 and 0.696, respectively.\nThe parameter estimates under the era2002 and after and length:era2002 and after are the differences in intercept and slope between the two eras. Thus, these values need to be added to the intercept and slope for the “pre-2000” era to estimate the intercept and slope for the “2002 and after” era. Thus, the estimated intercept and slope of the logistic regression for the “2002 and after” era fish are -13.118 and 0.345, respectively.\nThe first step in building the hypothesis test for whether \\(L_{50}\\) differs between eras is to construct the bootstrap samples from the glm() object.\n\nbcL3 <- car::Boot(glm3)  \nheadtail(bcL3$t)\n\n#R|         (Intercept)    length era2002 and after length:era2002 and after\n#R|  [1,]     -18.80167 0.4746840          6.963441               -0.1613036\n#R|  [2,]     -23.72944 0.6336083         14.644565               -0.3923172\n#R|  [3,]     -45.05273 1.1581163         25.728301               -0.6624715\n#R|  [997,]   -27.95516 0.7594994         13.718180               -0.3952151\n#R|  [998,]   -28.78888 0.7606613         20.036183               -0.5105222\n#R|  [999,]   -34.05215 0.8546306         17.169055               -0.4233520\n\n\nThe \\(L_{50}\\) for fish from the “pre-2002” era is computed for each sample using only the first two columns of the bootstrap sample results (i.e., the intercept and slope for the “pre-2002” era) and the lrperc() function created and used in a previous section. The \\(L_{50}\\) for fish from the “2002 and after” era is computed similarly but the last two columns in the bootstrap sample results must be added to the first two columns (i.e., produce the intercept and slope for the “2002 and after” era).\n\nL50.pre= apply(bcL3$t[,1:2],1,lrPerc,p=0.5)\nL50.post=apply(bcL3$t[,1:2]+bcL3$t[,3:4],1,lrPerc,p=0.5)\n\nIf there was no difference in \\(L_{50}\\) between the two eras, then one would expect the means of these two groups to be the same or, equivalently, the mean of the differences in these two value to equal zero. The difference in \\(L_{50}\\) for each bootstrap sample is computed below.\n\nL50.diff <- L50.pre-L50.post\n\nA two-sided p-value may be computed as two times the smaller of the proportions of samples that are less than or greater than 0.55 This code exploits the fact that R treats a TRUE as a 1 and a FALSE as a 0 such that the mean of a vector of TRUEs and FALSEs will return the proportion of TRUEs.\n\n( p.L50.diff <- 2*min(c(mean(L50.diff>0),mean(L50.diff<0))) )\n\n#R|  [1] 0.5405405\n\n\nThis result suggests that there is no significant difference in the \\(L_{50}\\) for fish captured in the two eras (not surprising given that the logistic regression parameters did not differ between eras).\nConfidence intervals for the difference in \\(L_{50}\\) between the eras and the \\(L_{50}\\) for each era may be computed as before but making sure to use the correct vector of results.\n\n( ci.L50.diff <- quantile(L50.diff,c(0.025,0.975)) )\n\n#R|       2.5%     97.5% \n#R|  -1.856107  4.625132\n\n( ci.L50.pre <-  quantile(L50.pre,c(0.025,0.975)) )\n\n#R|      2.5%    97.5% \n#R|  37.25822 40.90922\n\n( ci.L50.post <- quantile(L50.post,c(0.025,0.975)) )\n\n#R|      2.5%    97.5% \n#R|  34.99124 40.29840"
  },
  {
    "objectID": "supplements/maturity.html#a-summary-plot-1",
    "href": "supplements/maturity.html#a-summary-plot-1",
    "title": "Maturity Analyses",
    "section": "A Summary Plot",
    "text": "A Summary Plot\nThe construction of a plot that illustrates the fitted logistic regression lines for both groups is left largely as an exercise for the reader. Note that the code below uses several of the same ideas shown previously and relies on directions given in Chapter 3 of Ogle (2016).\n\n## Set-up colors\nclrs1 <- c(\"black\",\"red\")\nclrs2 <- col2rgbt(clrs1,1/5)\n## Get predicted values for each era\nlvls <- levels(df$era)\nlens <- seq(30,70,length.out=99)\npa02 <- predict(glm3,type=\"response\",\n                data.frame(length=lens,era=factor(\"2002 and after\",levels=lvls)))\npp02 <- predict(glm3,type=\"response\",\n                data.frame(length=lens,era=factor(\"pre-2002\",levels=lvls)))\n## Make the base plot\nplot((as.numeric(maturity)-1)~length,data=filter(df,era==lvls[1]),\n     pch=19,col=clrs2[1],xlab=\"Total Length (cm)\",ylab=\"Proportion Mature\")\npoints((as.numeric(maturity)-1)~length,data=filter(df,era==lvls[2]),\n     pch=19,col=clrs2[2])\n## Add the two fitted lines\nlines(pa02~lens,lwd=2,col=clrs1[1])\nlines(pp02~lens,lwd=2,col=clrs1[2])\n\n\n\n\nFigure 4: Fitted logistic regression for the proportion of female Yelloweye Rockfish that are mature by total length separated by the ‘pre-2002’ and ‘2002 and after’ eras."
  }
]